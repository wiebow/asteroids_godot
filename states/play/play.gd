# play.gd

extends Node2D

# This scene controls game flow for Asteroids.
# For this, it listens to events generated by the game objects
# or by variable changes in _process()

# define game constants

const EXTRA_LIFE := 10000
const GAME_MAX_ASTEROIDS := 10
const GAME_MAX_ASTEROIDS_SPLIT := 10
const GAME_MAX_SAUCERS := 5
const GAME_MAX_SPLIT := 10

# define game variables

var life_given := false
var game_over := false
var score := 0
var level := 0
var level_start_asteroids := 0
var level_split_count := 0
var level_saucers := 0
var level_max_saucers := 0

onready var camera := $GameCamera as Camera2D
onready var saucer_timer := $SaucerGenerateTimer as Timer

onready var player = $Player as Player
onready var level_sound : AudioStreamPlayer = $LevelSound
onready var extra_life_sound : AudioStreamPlayer = $LifeSound

onready var bullet_node : Node = $BulletNode
onready var explosion_node : Node = $ExplosionNode
onready var enemy_node : Node = $EnemyNode


# Called when the node enters the scene tree for the first time.
# So at the start of a new game.
func _ready():

	# connect to events created by other game objects
	Events.connect("points_awarded", self, "_on_points_awarded")

	Events.connect("create_explosion", self, "_on_create_explosion")
	Events.connect("create_bullet", self, "_on_create_bullet")
	Events.connect("create_asteroid", self, "_on_create_asteroid")
	Events.connect("create_saucer_bullet", self, "_on_create_saucer_bullet")
	
	Events.connect("game_over", self, "_on_game_over")
	Events.connect("wipe_finished", self, "_on_wipe_finished")

	life_given = false
	game_over = false
	
	player.lives = 2
	player.warps = 3
	score = 0
	level = 1
	
	# update the gui
	Events.emit_signal("gui_change_lives", player.lives)
	Events.emit_signal("gui_change_warps", player.warps)
	Events.emit_signal("gui_change_score", score)
	Events.emit_signal("gui_change_level", level)
	Events.emit_signal("gui_stats_visible", true)
	
	level_start_asteroids = 2
	level_split_count = 2
	level_max_saucers = 0
	level_saucers = 0
	
	_generate_start_asteroids()
	
	player.reset()
	level_sound.play()

	# fade in this scene
	Events.emit_signal("request_wipe", "fade_in")


func _process(_delta: float) -> void:
	# if this node is empty, that means we finished the level!
	if enemy_node.get_child_count() == 0:
		_on_level_clear()
		
	if Input.is_action_just_pressed("player_quit"):
		Events.emit_signal("request_wipe", "fade_out")


func generate_points_label(points:int, position:Vector2) -> void:
	var scene := preload("res://objects/pointslabel/pointslabel.tscn")
	var label := scene.instance()
	bullet_node.add_child(label)
	label.initialize(points, position)


func _generate_start_asteroids() -> void:
	var count := 0
	var scene := preload("res://objects/asteroid/asteroid.tscn")

	while count < level_start_asteroids:
		var asteroid = scene.instance()
		asteroid.initialize(1) # 1 means large asteroid
		asteroid.set_position( Vector2(rand_range(0, 800),
									rand_range(0, 600)))

		enemy_node.add_child(asteroid)
		count += 1


func _on_create_bullet(new_position: Vector2, new_degrees: float) -> void:
	var scene := preload("res://objects/playerbullet/player_bullet.tscn")
	var bullet = scene.instance()
	bullet.initialize(new_position, new_degrees)
	bullet_node.add_child(bullet)


func _on_create_saucer() -> void:
	var scene := preload("res://objects/saucer/saucer.tscn")
	var saucer = scene.instance()
	enemy_node.add_child(saucer)
	level_saucers += 1


func _on_create_saucer_bullet(new_position: Vector2) -> void:
	var scene = load("res://objects/saucerbullet/saucer_bullet.tscn")
	var bullet = scene.instance()
	bullet.initialize( new_position, rand_range(0, 360) )
	bullet_node.add_child(bullet)


func _on_create_explosion(new_position: Vector2) -> void:
	var scene := preload("res://objects/explosion/explosion.tscn")
	var explosion = scene.instance()
	explosion.position = new_position
	explosion_node.add_child(explosion)

	camera.shake(4.0)


func _on_create_asteroid(new_position: Vector2, size: int) -> void:

	# amount is determined by the current split value of the level
	var count := 0
	var scene := preload("res://objects/asteroid/asteroid.tscn")

	while count < level_split_count:
		var asteroid = scene.instance()
		asteroid.initialize(size)
		asteroid.set_position(new_position)

		# we need to call deferred because this function
		# is triggered by an event IN the asteroid
		# collision area loop (physics server proces)
		enemy_node.call_deferred("add_child", asteroid)
		count += 1


# we go to the next level
func _on_level_clear() -> void:

	# give points bonus
	_on_points_awarded(1000, null)

	level += 1
	player.warps += 1
	Events.emit_signal("gui_change_level", level)
	Events.emit_signal("gui_change_warps", player.warps)
	
	level_start_asteroids += 1
	level_start_asteroids = clamp(level_start_asteroids, 0, GAME_MAX_ASTEROIDS)

	level_split_count += 1
	level_split_count = clamp(level_split_count, 2, GAME_MAX_SPLIT)

	level_saucers = 0
	level_max_saucers += 1
	level_max_saucers = clamp(level_max_saucers, 0, GAME_MAX_SAUCERS)
	
	# reset the generate delay
	saucer_timer.wait_time = 20.0
	saucer_timer.start()

	_generate_start_asteroids()
	
	# make player invincible for 3 secs
	player.invincible()

	# play sound effect
	level_sound.play()



func _on_points_awarded(amount: int, new_position) -> void:
	score += amount
	Events.emit_signal("gui_change_score", score)
	if score > Score.get_hi_score():
		Events.emit_signal("gui_change_hiscore", score)
	
	
	# if position is passed, then also add a score label
	if new_position != null:
		generate_points_label(amount, new_position)
	
	# check if we need to give an extra life.
	if not life_given:
		if score > EXTRA_LIFE:
			life_given = true
			player.lives += 1
			extra_life_sound.play()


func _on_game_over() -> void:
	
	# used by the PauseDisplay scene to determine if pause can be activated
	game_over = true
		
	# add the gameover scene to this play scene to display
	# the total score, and show the name entry when a new hiscore
	# has been reached.
	var scene = preload("res://states/gameover/game_over.tscn")
	var gameover = scene.instance()
	
	self.add_child(gameover)

	# let the scene decide if the score is high enough for name entry
	gameover.setup(score)


# this fade out is started in the gameover scene
func _on_wipe_finished(name) -> void:
	if name == "fade_out":
		SceneSwitcher.goto_scene("res://states/title/title.tscn")


func _on_SaucerGenerateTimer_timeout():

	# restart the generate timer.
	# make the delay slightly shorter
	var delay: float = saucer_timer.wait_time -1
	if delay < 1.0:
			delay = 1.0
	saucer_timer.wait_time = delay
	saucer_timer.start()
	
	# don't generate a saucer if the limit is reached
	if level_saucers == level_max_saucers:
		return
	
	_on_create_saucer()
